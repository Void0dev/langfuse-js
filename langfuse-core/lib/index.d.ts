/// <reference types="node" />
declare abstract class BasePromptClient {
    readonly name: string;
    readonly version: number;
    readonly config: unknown;
    constructor(prompt: CreateLangfusePromptResponse);
    abstract compile(variables?: Record<string, string>): string | ChatMessage[];
    abstract getLangchainPrompt(): string | ChatMessage[];
    protected _transformToLangchainVariables(content: string): string;
}
declare class TextPromptClient extends BasePromptClient {
    readonly promptResponse: TextPrompt;
    readonly prompt: string;
    constructor(prompt: TextPrompt);
    compile(variables?: Record<string, string>): string;
    getLangchainPrompt(): string;
}
declare class ChatPromptClient extends BasePromptClient {
    readonly promptResponse: ChatPrompt;
    readonly prompt: ChatMessage[];
    constructor(prompt: ChatPrompt);
    compile(variables?: Record<string, string>): ChatMessage[];
    getLangchainPrompt(): ChatMessage[];
}
type LangfusePromptClient = TextPromptClient | ChatPromptClient;

/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */
/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};
/** OneOf type helpers */
type Without<T, U> = {
    [P in Exclude<keyof T, keyof U>]?: never;
};
type XOR<T, U> = T | U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;
interface paths {
    "/api/public/dataset-items": {
        /** @description Create a dataset item */
        post: operations["datasetItems_create"];
    };
    "/api/public/dataset-items/{id}": {
        /** @description Get a dataset item */
        get: operations["datasetItems_get"];
    };
    "/api/public/dataset-run-items": {
        /** @description Create a dataset run item */
        post: operations["datasetRunItems_create"];
    };
    "/api/public/datasets": {
        /** @description Get all datasets */
        get: operations["datasets_list"];
        /** @description Create a dataset */
        post: operations["datasets_create"];
    };
    "/api/public/datasets/{datasetName}": {
        /** @description Get a dataset and its items */
        get: operations["datasets_get"];
    };
    "/api/public/datasets/{datasetName}/runs/{runName}": {
        /** @description Get a dataset run and its items */
        get: operations["datasets_getRuns"];
    };
    "/api/public/health": {
        /** @description Check health of API and database */
        get: operations["health_health"];
    };
    "/api/public/ingestion": {
        /** @description Batched ingestion for Langfuse Tracing */
        post: operations["ingestion_batch"];
    };
    "/api/public/metrics/daily": {
        /** @description Get daily metrics of the Langfuse project */
        get: operations["metrics_daily"];
    };
    "/api/public/observations/{observationId}": {
        /** @description Get a observation */
        get: operations["observations_get"];
    };
    "/api/public/observations": {
        /** @description Get a list of observations */
        get: operations["observations_getMany"];
    };
    "/api/public/projects": {
        /** @description Get Project associated with API key */
        get: operations["projects_get"];
    };
    "/api/public/prompts": {
        /** @description Get a prompt */
        get: operations["prompts_get"];
        /** @description Create a prompt */
        post: operations["prompts_create"];
    };
    "/api/public/scores": {
        /** @description Get a list of scores */
        get: operations["score_get"];
        /** @description Create a score */
        post: operations["score_create"];
    };
    "/api/public/scores/{scoreId}": {
        /** @description Get a score */
        get: operations["score_get-by-id"];
        /** @description Delete a score */
        delete: operations["score_delete"];
    };
    "/api/public/sessions/{sessionId}": {
        /** @description Get a session */
        get: operations["sessions_get"];
    };
    "/api/public/traces/{traceId}": {
        /** @description Get a specific trace */
        get: operations["trace_get"];
    };
    "/api/public/traces": {
        /** @description Get list of traces */
        get: operations["trace_list"];
    };
}
type webhooks = Record<string, never>;
interface components {
    schemas: {
        /** Trace */
        Trace: {
            /** @description The unique identifier of a trace */
            id: string;
            /** Format: date-time */
            timestamp: string;
            name?: string | null;
            input?: unknown;
            output?: unknown;
            sessionId?: string | null;
            release?: string | null;
            version?: string | null;
            userId?: string | null;
            metadata?: unknown;
            tags?: string[] | null;
            /** @description Public traces are accessible via url without login */
            public?: boolean | null;
        };
        /** TraceWithDetails */
        TraceWithDetails: WithRequired<{
            /** @description Path of trace in Langfuse UI */
            htmlPath: string;
            /**
             * Format: double
             * @description Latency of trace in seconds
             */
            latency: number;
            /**
             * Format: double
             * @description Cost of trace in USD
             */
            totalCost: number;
            /** @description List of observation ids */
            observations: string[];
            /** @description List of score ids */
            scores: string[];
        } & components["schemas"]["Trace"], "htmlPath" | "latency" | "totalCost" | "observations" | "scores">;
        /** TraceWithFullDetails */
        TraceWithFullDetails: WithRequired<{
            /** @description Path of trace in Langfuse UI */
            htmlPath: string;
            /**
             * Format: double
             * @description Cost of trace in USD
             */
            totalCost: number;
            observations: components["schemas"]["ObservationsView"][];
            scores: components["schemas"]["Score"][];
        } & components["schemas"]["Trace"], "htmlPath" | "totalCost" | "observations" | "scores">;
        /** Session */
        Session: {
            id: string;
            /** Format: date-time */
            createdAt: string;
            projectId: string;
        };
        /** SessionWithTraces */
        SessionWithTraces: WithRequired<{
            traces: components["schemas"]["Trace"][];
        } & components["schemas"]["Session"], "traces">;
        /** Observation */
        Observation: {
            id: string;
            traceId?: string | null;
            type: string;
            name?: string | null;
            /** Format: date-time */
            startTime: string;
            /** Format: date-time */
            endTime?: string | null;
            /** Format: date-time */
            completionStartTime?: string | null;
            model?: string | null;
            modelParameters?: {
                [key: string]: components["schemas"]["MapValue"];
            } | null;
            input?: unknown;
            version?: string | null;
            metadata?: unknown;
            output?: unknown;
            usage?: components["schemas"]["Usage"];
            level: components["schemas"]["ObservationLevel"];
            statusMessage?: string | null;
            parentObservationId?: string | null;
            promptId?: string | null;
        };
        /** ObservationsView */
        ObservationsView: {
            modelId?: string | null;
            /** Format: double */
            inputPrice?: number | null;
            /** Format: double */
            outputPrice?: number | null;
            /** Format: double */
            totalPrice?: number | null;
            /** Format: double */
            calculatedInputCost?: number | null;
            /** Format: double */
            calculatedOutputCost?: number | null;
            /** Format: double */
            calculatedTotalCost?: number | null;
            /** Format: double */
            latency?: number | null;
        } & components["schemas"]["Observation"];
        /**
         * Usage
         * @description Standard interface for usage and cost
         */
        Usage: {
            /** @description Number of input units (e.g. tokens) */
            input?: number | null;
            /** @description Number of output units (e.g. tokens) */
            output?: number | null;
            /** @description Defaults to input+output if not set */
            total?: number | null;
            unit?: components["schemas"]["ModelUsageUnit"];
            /**
             * Format: double
             * @description USD input cost
             */
            inputCost?: number | null;
            /**
             * Format: double
             * @description USD output cost
             */
            outputCost?: number | null;
            /**
             * Format: double
             * @description USD total cost, defaults to input+output
             */
            totalCost?: number | null;
        };
        /** Score */
        Score: {
            id: string;
            traceId: string;
            name: string;
            /** Format: double */
            value: number;
            source: components["schemas"]["ScoreSource"];
            observationId?: string | null;
            /** Format: date-time */
            timestamp: string;
            comment?: string | null;
        };
        /** DatasetCore */
        DatasetCore: {
            id: string;
            name: string;
            description?: string | null;
            metadata?: unknown;
            projectId: string;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
        };
        /** DatasetWithReferences */
        DatasetWithReferences: WithRequired<{
            /** @description list of dataset item ids */
            items: string[];
            /** @description list of dataset run names */
            runs: string[];
        } & components["schemas"]["DatasetCore"], "items" | "runs">;
        /**
         * Dataset
         * @description Dataset including all items
         */
        Dataset: WithRequired<{
            items: components["schemas"]["DatasetItem"][];
            runs: string[];
        } & components["schemas"]["DatasetCore"], "items" | "runs">;
        /** DatasetItem */
        DatasetItem: {
            id: string;
            status: components["schemas"]["DatasetStatus"];
            input?: unknown;
            expectedOutput?: unknown;
            metadata?: unknown;
            sourceTraceId?: string | null;
            sourceObservationId?: string | null;
            datasetId: string;
            datasetName: string;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
        };
        /** DatasetRunItem */
        DatasetRunItem: {
            id: string;
            datasetRunId: string;
            datasetRunName: string;
            datasetItemId: string;
            traceId: string;
            observationId?: string | null;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
        };
        /** DatasetRun */
        DatasetRun: {
            id: string;
            name: string;
            description?: string | null;
            metadata?: unknown;
            datasetId: string;
            datasetName: string;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
            datasetRunItems: components["schemas"]["DatasetRunItem"][];
        };
        /**
         * ModelUsageUnit
         * @description Unit of usage in Langfuse
         * @enum {string}
         */
        ModelUsageUnit: "CHARACTERS" | "TOKENS" | "MILLISECONDS" | "SECONDS" | "IMAGES";
        /**
         * ObservationLevel
         * @enum {string}
         */
        ObservationLevel: "DEBUG" | "DEFAULT" | "WARNING" | "ERROR";
        /** MapValue */
        MapValue: (string | null) | (number | null) | (boolean | null) | (string[] | null);
        /**
         * DatasetStatus
         * @enum {string}
         */
        DatasetStatus: "ACTIVE" | "ARCHIVED";
        /**
         * ScoreSource
         * @enum {string}
         */
        ScoreSource: "API" | "REVIEW" | "EVAL";
        /** CreateDatasetItemRequest */
        CreateDatasetItemRequest: {
            datasetName: string;
            input?: unknown;
            expectedOutput?: unknown;
            metadata?: unknown;
            sourceTraceId?: string | null;
            sourceObservationId?: string | null;
            /** @description Dataset items are upserted on their id */
            id?: string | null;
        };
        /** CreateDatasetRunItemRequest */
        CreateDatasetRunItemRequest: {
            runName: string;
            /** @description Description of the run. If run exists, description will be updated. */
            runDescription?: string | null;
            /** @description Metadata of the dataset run, updates run if run already exists */
            metadata?: unknown;
            datasetItemId: string;
            observationId?: string | null;
            /** @description traceId should always be provided. For compatibility with older SDK versions it can also be inferred from the provided observationId. */
            traceId?: string | null;
        };
        /** PaginatedDatasets */
        PaginatedDatasets: {
            data: components["schemas"]["DatasetWithReferences"][];
            meta: components["schemas"]["utilsMetaResponse"];
        };
        /** CreateDatasetRequest */
        CreateDatasetRequest: {
            name: string;
            description?: string | null;
            metadata?: unknown;
        };
        /** HealthResponse */
        HealthResponse: {
            /**
             * @description Langfuse server version
             * @example 1.25.0
             */
            version: string;
            /** @example OK */
            status: string;
        };
        /** IngestionEvent */
        IngestionEvent: WithRequired<{
            /** @enum {string} */
            type?: "trace-create";
        } & components["schemas"]["TraceEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "score-create";
        } & components["schemas"]["ScoreEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "event-create";
        } & components["schemas"]["CreateEventEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "generation-create";
        } & components["schemas"]["CreateGenerationEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "generation-update";
        } & components["schemas"]["UpdateGenerationEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "span-create";
        } & components["schemas"]["CreateSpanEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "span-update";
        } & components["schemas"]["UpdateSpanEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "sdk-log";
        } & components["schemas"]["SDKLogEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "observation-create";
        } & components["schemas"]["CreateObservationEvent"], "type"> | WithRequired<{
            /** @enum {string} */
            type?: "observation-update";
        } & components["schemas"]["UpdateObservationEvent"], "type">;
        /**
         * ObservationType
         * @enum {string}
         */
        ObservationType: "SPAN" | "GENERATION" | "EVENT";
        /** IngestionUsage */
        IngestionUsage: components["schemas"]["Usage"] | components["schemas"]["OpenAIUsage"];
        /**
         * OpenAIUsage
         * @description Usage interface of OpenAI for improved compatibility.
         */
        OpenAIUsage: {
            promptTokens?: number | null;
            completionTokens?: number | null;
            totalTokens?: number | null;
        };
        /** OptionalObservationBody */
        OptionalObservationBody: {
            traceId?: string | null;
            name?: string | null;
            /** Format: date-time */
            startTime?: string | null;
            metadata?: unknown;
            input?: unknown;
            output?: unknown;
            level?: components["schemas"]["ObservationLevel"];
            statusMessage?: string | null;
            parentObservationId?: string | null;
            version?: string | null;
        };
        /** CreateEventBody */
        CreateEventBody: {
            id?: string | null;
        } & components["schemas"]["OptionalObservationBody"];
        /** UpdateEventBody */
        UpdateEventBody: WithRequired<{
            id: string;
        } & components["schemas"]["OptionalObservationBody"], "id">;
        /** CreateSpanBody */
        CreateSpanBody: {
            /** Format: date-time */
            endTime?: string | null;
        } & components["schemas"]["CreateEventBody"];
        /** UpdateSpanBody */
        UpdateSpanBody: {
            /** Format: date-time */
            endTime?: string | null;
        } & components["schemas"]["UpdateEventBody"];
        /** CreateGenerationBody */
        CreateGenerationBody: {
            /** Format: date-time */
            completionStartTime?: string | null;
            model?: string | null;
            modelParameters?: {
                [key: string]: components["schemas"]["MapValue"];
            } | null;
            usage?: components["schemas"]["IngestionUsage"];
            promptName?: string | null;
            promptVersion?: number | null;
        } & components["schemas"]["CreateSpanBody"];
        /** UpdateGenerationBody */
        UpdateGenerationBody: {
            /** Format: date-time */
            completionStartTime?: string | null;
            model?: string | null;
            modelParameters?: {
                [key: string]: components["schemas"]["MapValue"];
            } | null;
            usage?: components["schemas"]["IngestionUsage"];
            promptName?: string | null;
            promptVersion?: number | null;
        } & components["schemas"]["UpdateSpanBody"];
        /** ObservationBody */
        ObservationBody: {
            id?: string | null;
            traceId?: string | null;
            type: components["schemas"]["ObservationType"];
            name?: string | null;
            /** Format: date-time */
            startTime?: string | null;
            /** Format: date-time */
            endTime?: string | null;
            /** Format: date-time */
            completionStartTime?: string | null;
            model?: string | null;
            modelParameters?: {
                [key: string]: components["schemas"]["MapValue"];
            } | null;
            input?: unknown;
            version?: string | null;
            metadata?: unknown;
            output?: unknown;
            usage?: components["schemas"]["Usage"];
            level?: components["schemas"]["ObservationLevel"];
            statusMessage?: string | null;
            parentObservationId?: string | null;
        };
        /** TraceBody */
        TraceBody: {
            id?: string | null;
            /** Format: date-time */
            timestamp?: string | null;
            name?: string | null;
            userId?: string | null;
            input?: unknown;
            output?: unknown;
            sessionId?: string | null;
            release?: string | null;
            version?: string | null;
            metadata?: unknown;
            tags?: string[] | null;
            /** @description Make trace publicly accessible via url */
            public?: boolean | null;
        };
        /** SDKLogBody */
        SDKLogBody: {
            log: unknown;
        };
        /** ScoreBody */
        ScoreBody: {
            id?: string | null;
            traceId: string;
            name: string;
            /** Format: double */
            value: number;
            observationId?: string | null;
            comment?: string | null;
        };
        /** BaseEvent */
        BaseEvent: {
            id: string;
            timestamp: string;
            metadata: unknown;
        };
        /** TraceEvent */
        TraceEvent: WithRequired<{
            body: components["schemas"]["TraceBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** CreateObservationEvent */
        CreateObservationEvent: WithRequired<{
            body: components["schemas"]["ObservationBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** UpdateObservationEvent */
        UpdateObservationEvent: WithRequired<{
            body: components["schemas"]["ObservationBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** ScoreEvent */
        ScoreEvent: WithRequired<{
            body: components["schemas"]["ScoreBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** SDKLogEvent */
        SDKLogEvent: WithRequired<{
            body: components["schemas"]["SDKLogBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** CreateGenerationEvent */
        CreateGenerationEvent: WithRequired<{
            body: components["schemas"]["CreateGenerationBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** UpdateGenerationEvent */
        UpdateGenerationEvent: WithRequired<{
            body: components["schemas"]["UpdateGenerationBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** CreateSpanEvent */
        CreateSpanEvent: WithRequired<{
            body: components["schemas"]["CreateSpanBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** UpdateSpanEvent */
        UpdateSpanEvent: WithRequired<{
            body: components["schemas"]["UpdateSpanBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** CreateEventEvent */
        CreateEventEvent: WithRequired<{
            body: components["schemas"]["CreateEventBody"];
        } & components["schemas"]["BaseEvent"], "body">;
        /** IngestionSuccess */
        IngestionSuccess: {
            id: string;
            status: number;
        };
        /** IngestionError */
        IngestionError: {
            id: string;
            status: number;
            message?: string | null;
            error?: unknown;
        };
        /** IngestionResponse */
        IngestionResponse: {
            successes: components["schemas"]["IngestionSuccess"][];
            errors: components["schemas"]["IngestionError"][];
        };
        /** DailyMetrics */
        DailyMetrics: {
            /** @description A list of daily metrics, only days with ingested data are included. */
            data: components["schemas"]["DailyMetricsDetails"][];
            meta: components["schemas"]["utilsMetaResponse"];
        };
        /** DailyMetricsDetails */
        DailyMetricsDetails: {
            date: string;
            countTraces: number;
            /** Format: double */
            totalCost: number;
            usage: components["schemas"]["UsageByModel"][];
        };
        /**
         * UsageByModel
         * @description Daily usage of a given model. Usage corresponds to the unit set for the specific model (e.g. tokens).
         */
        UsageByModel: {
            model: string;
            inputUsage: number;
            outputUsage: number;
            totalUsage: number;
        };
        /** Observations */
        Observations: {
            data: components["schemas"]["Observation"][];
            meta: components["schemas"]["utilsMetaResponse"];
        };
        /** ObservationsViews */
        ObservationsViews: {
            data: components["schemas"]["ObservationsView"][];
            meta: components["schemas"]["utilsMetaResponse"];
        };
        /** Projects */
        Projects: {
            data: components["schemas"]["Project"][];
        };
        /** Project */
        Project: {
            id: string;
            name: string;
        };
        /** CreatePromptRequest */
        CreatePromptRequest: OneOf<[
            WithRequired<{
                /** @enum {string} */
                type?: "chat";
            } & components["schemas"]["CreateChatPromptRequest"], "type">,
            WithRequired<{
                /** @enum {string} */
                type?: "text";
            } & components["schemas"]["CreateTextPromptRequest"], "type">
        ]>;
        /** CreateChatPromptRequest */
        CreateChatPromptRequest: {
            name: string;
            /** @description Should the prompt be promoted to production immediately? */
            isActive: boolean;
            prompt: components["schemas"]["ChatMessage"][];
            config?: unknown;
        };
        /** CreateTextPromptRequest */
        CreateTextPromptRequest: {
            name: string;
            /** @description Should the prompt be promoted to production immediately? */
            isActive: boolean;
            prompt: string;
            config?: unknown;
        };
        /** Prompt */
        Prompt: OneOf<[
            WithRequired<{
                /** @enum {string} */
                type?: "chat";
            } & components["schemas"]["ChatPrompt"], "type">,
            WithRequired<{
                /** @enum {string} */
                type?: "text";
            } & components["schemas"]["TextPrompt"], "type">
        ]>;
        /** BasePrompt */
        BasePrompt: {
            name: string;
            version: number;
            config: unknown;
        };
        /** ChatMessage */
        ChatMessage: {
            role: string;
            content: string;
        };
        /** TextPrompt */
        TextPrompt: WithRequired<{
            prompt: string;
        } & components["schemas"]["BasePrompt"], "prompt">;
        /** ChatPrompt */
        ChatPrompt: WithRequired<{
            prompt: components["schemas"]["ChatMessage"][];
        } & components["schemas"]["BasePrompt"], "prompt">;
        /** CreateScoreRequest */
        CreateScoreRequest: {
            id?: string | null;
            traceId: string;
            name: string;
            /** Format: double */
            value: number;
            observationId?: string | null;
            comment?: string | null;
        };
        /** Scores */
        Scores: {
            data: components["schemas"]["Score"][];
            meta: components["schemas"]["utilsMetaResponse"];
        };
        /** Traces */
        Traces: {
            data: components["schemas"]["TraceWithDetails"][];
            meta: components["schemas"]["utilsMetaResponse"];
        };
        /** Sort */
        Sort: {
            id: string;
        };
        /** utilsMetaResponse */
        utilsMetaResponse: {
            /** @description current page number */
            page: number;
            /** @description number of items per page */
            limit: number;
            /** @description number of total items given the current filters/selection (if any) */
            totalItems: number;
            /** @description number of total pages given the current limit */
            totalPages: number;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
type $defs = Record<string, never>;
type external = Record<string, never>;
interface operations {
    /** @description Create a dataset item */
    datasetItems_create: {
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateDatasetItemRequest"];
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["DatasetItem"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a dataset item */
    datasetItems_get: {
        parameters: {
            path: {
                id: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["DatasetItem"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Create a dataset run item */
    datasetRunItems_create: {
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateDatasetRunItemRequest"];
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["DatasetRunItem"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get all datasets */
    datasets_list: {
        parameters: {
            query?: {
                page?: number | null;
                limit?: number | null;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["PaginatedDatasets"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Create a dataset */
    datasets_create: {
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateDatasetRequest"];
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Dataset"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a dataset and its items */
    datasets_get: {
        parameters: {
            path: {
                datasetName: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Dataset"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a dataset run and its items */
    datasets_getRuns: {
        parameters: {
            path: {
                datasetName: string;
                runName: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["DatasetRun"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Check health of API and database */
    health_health: {
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
            503: {
                content: never;
            };
        };
    };
    /** @description Batched ingestion for Langfuse Tracing */
    ingestion_batch: {
        requestBody: {
            content: {
                "application/json": {
                    batch: components["schemas"]["IngestionEvent"][];
                };
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["IngestionResponse"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get daily metrics of the Langfuse project */
    metrics_daily: {
        parameters: {
            query?: {
                /** @description page number, starts at 1 */
                page?: number | null;
                /** @description limit of items per page */
                limit?: number | null;
                /** @description Optional filter by the name of the trace */
                traceName?: string | null;
                /** @description Optional filter by the userId associated with the trace */
                userId?: string | null;
                /** @description Optional filter for metrics where traces include all of these tags */
                tags?: (string | null)[];
                /** @description Optional filter to only include traces on or after a certain timestamp */
                fromTimestamp?: string | null;
                /** @description Optional filter to only include traces before a certain timestamp */
                toTimestamp?: string | null;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["DailyMetrics"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a observation */
    observations_get: {
        parameters: {
            path: {
                /** @description The unique langfuse identifier of an observation, can be an event, span or generation */
                observationId: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["ObservationsView"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a list of observations */
    observations_getMany: {
        parameters: {
            query?: {
                /** @description page number, starts at 1 */
                page?: number | null;
                /** @description limit of items per page */
                limit?: number | null;
                name?: string | null;
                userId?: string | null;
                type?: string | null;
                traceId?: string | null;
                parentObservationId?: string | null;
                /** @description Retrieve only observations with a start_time greater than this timestamp. */
                fromStartTime?: string | null;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["ObservationsViews"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get Project associated with API key */
    projects_get: {
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Projects"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a prompt */
    prompts_get: {
        parameters: {
            query: {
                name: string;
                version?: number | null;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Prompt"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Create a prompt */
    prompts_create: {
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePromptRequest"];
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Prompt"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a list of scores */
    score_get: {
        parameters: {
            query: {
                /** @description page number, starts at 1 */
                page?: number | null;
                /** @description limit of items per page */
                limit?: number | null;
                userId?: string | null;
                name?: string | null;
                /** @description Retrieve only scores newer than this timestamp. */
                fromTimestamp?: string | null;
                /** @description Retrieve only scores from a specific source. */
                source: components["schemas"]["ScoreSource"];
                /** @description Retrieve only scores with <operator> value. */
                operator?: string | null;
                /** @description Retrieve only scores with <operator> value. */
                value?: number | null;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Scores"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Create a score */
    score_create: {
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateScoreRequest"];
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Score"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a score */
    "score_get-by-id": {
        parameters: {
            path: {
                /** @description The unique langfuse identifier of a score */
                scoreId: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Score"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Delete a score */
    score_delete: {
        parameters: {
            path: {
                /** @description The unique langfuse identifier of a score */
                scoreId: string;
            };
        };
        responses: {
            204: {
                content: never;
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a session */
    sessions_get: {
        parameters: {
            path: {
                /** @description The unique id of a session */
                sessionId: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["SessionWithTraces"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get a specific trace */
    trace_get: {
        parameters: {
            path: {
                /** @description The unique langfuse identifier of a trace */
                traceId: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["TraceWithFullDetails"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    /** @description Get list of traces */
    trace_list: {
        parameters: {
            query?: {
                /** @description page number, starts at 1 */
                page?: number | null;
                /** @description limit of items per page */
                limit?: number | null;
                userId?: string | null;
                name?: string | null;
                /** @description Retrieve only traces newer than this timestamp. */
                fromTimestamp?: string | null;
                /** @description Format of the string [field].[asc/desc]. Fields: id, timestamp, name, userId, release, version, public, bookmarked, sessionId. Example: timestamp.asc */
                orderBy?: string | null;
                /** @description Only traces that include all of these tags will be returned. */
                tags?: (string | null)[];
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Traces"];
                };
            };
            400: {
                content: {
                    "application/json": unknown;
                };
            };
            401: {
                content: {
                    "application/json": unknown;
                };
            };
            403: {
                content: {
                    "application/json": unknown;
                };
            };
            404: {
                content: {
                    "application/json": unknown;
                };
            };
            405: {
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}

type LangfuseCoreOptions = {
    baseUrl?: string;
    flushAt?: number;
    flushInterval?: number;
    fetchRetryCount?: number;
    fetchRetryDelay?: number;
    requestTimeout?: number;
    release?: string;
    sdkIntegration?: string;
};
declare enum LangfusePersistedProperty {
    Props = "props",
    Queue = "queue",
    OptedOut = "opted_out"
}
type LangfuseFetchOptions = {
    method: "GET" | "POST" | "PUT" | "PATCH";
    headers: {
        [key: string]: string;
    };
    body?: string;
    signal?: AbortSignal;
};
type LangfuseFetchResponse<T = any> = {
    status: number;
    text: () => Promise<string>;
    json: () => Promise<T>;
};
type LangfuseObject = SingleIngestionEvent["type"];
type LangfuseQueueItem = SingleIngestionEvent & {
    callback?: (err: any) => void;
};
type SingleIngestionEvent = paths["/api/public/ingestion"]["post"]["requestBody"]["content"]["application/json"]["batch"][number];
type IngestionReturnType = paths["/api/public/ingestion"]["post"]["responses"][200]["content"]["application/json"];
type LangfuseEventProperties = {
    [key: string]: any;
};
type LangfuseMetadataProperties = {
    [key: string]: any;
};
type CreateLangfuseTraceBody = FixTypes<components["schemas"]["TraceBody"]>;
type CreateLangfuseEventBody = FixTypes<components["schemas"]["CreateEventBody"]>;
type CreateLangfuseSpanBody = FixTypes<components["schemas"]["CreateSpanBody"]>;
type UpdateLangfuseSpanBody = FixTypes<components["schemas"]["UpdateSpanBody"]>;
type Usage = FixTypes<components["schemas"]["IngestionUsage"]>;
type CreateLangfuseGenerationBody = FixTypes<components["schemas"]["CreateGenerationBody"]>;
type UpdateLangfuseGenerationBody = FixTypes<components["schemas"]["UpdateGenerationBody"]>;
type CreateLangfuseScoreBody = FixTypes<components["schemas"]["ScoreBody"]>;
type GetLangfuseDatasetParams = FixTypes<paths["/api/public/datasets/{datasetName}"]["get"]["parameters"]["path"]>;
type GetLangfuseDatasetResponse = FixTypes<paths["/api/public/datasets/{datasetName}"]["get"]["responses"]["200"]["content"]["application/json"]>;
type CreateLangfuseDatasetRunItemBody = FixTypes<paths["/api/public/dataset-run-items"]["post"]["requestBody"]["content"]["application/json"]>;
type CreateLangfuseDatasetRunItemResponse = FixTypes<paths["/api/public/dataset-run-items"]["post"]["responses"]["200"]["content"]["application/json"]>;
type CreateLangfuseDatasetBody = paths["/api/public/datasets"]["post"]["requestBody"]["content"]["application/json"];
type CreateLangfuseDatasetResponse = FixTypes<paths["/api/public/datasets"]["post"]["responses"]["200"]["content"]["application/json"]>;
type CreateLangfuseDatasetItemBody = FixTypes<paths["/api/public/dataset-items"]["post"]["requestBody"]["content"]["application/json"]>;
type CreateLangfuseDatasetItemResponse = FixTypes<paths["/api/public/dataset-items"]["post"]["responses"]["200"]["content"]["application/json"]>;
type GetLangfuseDatasetRunParams = FixTypes<paths["/api/public/datasets/{datasetName}/runs/{runName}"]["get"]["parameters"]["path"]>;
type GetLangfuseDatasetRunResponse = FixTypes<paths["/api/public/datasets/{datasetName}/runs/{runName}"]["get"]["responses"]["200"]["content"]["application/json"]>;
type CreateLangfusePromptBody = FixTypes<paths["/api/public/prompts"]["post"]["requestBody"]["content"]["application/json"]>;
type CreateLangfusePromptResponse = paths["/api/public/prompts"]["post"]["responses"]["200"]["content"]["application/json"];
type GetLangfusePromptSuccessData = paths["/api/public/prompts"]["get"]["responses"]["200"]["content"]["application/json"];
type GetLangfusePromptFailureData = {
    message?: string;
};
type GetLangfusePromptResponse = {
    fetchResult: "success";
    data: GetLangfusePromptSuccessData;
} | {
    fetchResult: "failure";
    data: GetLangfusePromptFailureData;
};
type ChatMessage = FixTypes<components["schemas"]["ChatMessage"]>;
type ChatPrompt = FixTypes<components["schemas"]["ChatPrompt"]> & {
    type: "chat";
};
type TextPrompt = FixTypes<components["schemas"]["TextPrompt"]> & {
    type: "text";
};
type CreateTextPromptRequest = FixTypes<components["schemas"]["CreateTextPromptRequest"]>;
type CreateChatPromptRequest = FixTypes<components["schemas"]["CreateChatPromptRequest"]>;
type CreateTextPromptBody = {
    type?: "text";
} & Omit<CreateTextPromptRequest, "type">;
type CreateChatPromptBody = {
    type: "chat";
} & Omit<CreateChatPromptRequest, "type">;
type CreatePromptBody = CreateTextPromptBody | CreateChatPromptBody;
type PromptInput = {
    prompt?: LangfusePromptClient;
};
type JsonType = string | number | boolean | null | {
    [key: string]: JsonType;
} | Array<JsonType>;
type OptionalTypes<T> = T extends null | undefined ? T : never;
type FixTypes<T> = Omit<{
    [P in keyof T]: P extends "startTime" | "endTime" | "timestamp" | "completionStartTime" | "createdAt" | "updatedAt" ? // Dates instead of strings
    Date | OptionalTypes<T[P]> : P extends "metadata" | "input" | "output" | "completion" | "expectedOutput" ? // JSON instead of strings
    any | OptionalTypes<T[P]> : T[P];
}, "externalId" | "traceIdType">;
type DeferRuntime = {
    langfuseTraces: (traces: {
        id: string;
        name: string;
        url: string;
    }[]) => void;
};

declare function assert(truthyValue: any, message: string): void;
declare function removeTrailingSlash(url: string): string;
interface RetriableOptions {
    retryCount?: number;
    retryDelay?: number;
    retryCheck?: (err: any) => boolean;
}
declare function retriable<T>(fn: () => Promise<T>, props: RetriableOptions | undefined, log: (msg: string) => void): Promise<T>;
declare function generateUUID(globalThis?: any): string;
declare function currentTimestamp(): number;
declare function currentISOTime(): string;
declare function safeSetTimeout(fn: () => void, timeout: number): any;
declare function getEnv<T = string>(key: string): T | undefined;
type Params = LangfuseCoreOptions & {
    publicKey?: string;
    secretKey?: string;
};
declare function configLangfuseSDK(params?: Params, secretRequired?: boolean): Params;

type utils_d_RetriableOptions = RetriableOptions;
declare const utils_d_assert: typeof assert;
declare const utils_d_configLangfuseSDK: typeof configLangfuseSDK;
declare const utils_d_currentISOTime: typeof currentISOTime;
declare const utils_d_currentTimestamp: typeof currentTimestamp;
declare const utils_d_generateUUID: typeof generateUUID;
declare const utils_d_getEnv: typeof getEnv;
declare const utils_d_removeTrailingSlash: typeof removeTrailingSlash;
declare const utils_d_retriable: typeof retriable;
declare const utils_d_safeSetTimeout: typeof safeSetTimeout;
declare namespace utils_d {
  export { type utils_d_RetriableOptions as RetriableOptions, utils_d_assert as assert, utils_d_configLangfuseSDK as configLangfuseSDK, utils_d_currentISOTime as currentISOTime, utils_d_currentTimestamp as currentTimestamp, utils_d_generateUUID as generateUUID, utils_d_getEnv as getEnv, utils_d_removeTrailingSlash as removeTrailingSlash, utils_d_retriable as retriable, utils_d_safeSetTimeout as safeSetTimeout };
}

declare class SimpleEventEmitter {
    events: {
        [key: string]: ((...args: any[]) => void)[];
    };
    constructor();
    on(event: string, listener: (...args: any[]) => void): () => void;
    emit(event: string, payload: any): void;
}

declare class LangfuseMemoryStorage {
    private _memoryStorage;
    getProperty(key: LangfusePersistedProperty): any | undefined;
    setProperty(key: LangfusePersistedProperty, value: any | null): void;
}

type IngestionBody = SingleIngestionEvent["body"];

declare abstract class LangfuseCoreStateless {
    private secretKey;
    private publicKey;
    baseUrl: string;
    private flushAt;
    private flushInterval;
    private requestTimeout;
    private removeDebugCallback?;
    private debugMode;
    private pendingPromises;
    private release;
    private sdkIntegration;
    protected _events: SimpleEventEmitter;
    protected _flushTimer?: any;
    protected _retryOptions: RetriableOptions;
    abstract fetch(url: string, options: LangfuseFetchOptions): Promise<LangfuseFetchResponse>;
    abstract getLibraryId(): string;
    abstract getLibraryVersion(): string;
    abstract getPersistedProperty<T>(key: LangfusePersistedProperty): T | undefined;
    abstract setPersistedProperty<T>(key: LangfusePersistedProperty, value: T | null): void;
    constructor(params: {
        publicKey: string;
        secretKey?: string;
    } & LangfuseCoreOptions);
    getSdkIntegration(): string;
    protected getCommonEventProperties(): any;
    on(event: string, cb: (...args: any[]) => void): () => void;
    debug(enabled?: boolean): void;
    /***
     *** Handlers for each object type
     ***/
    protected traceStateless(body: CreateLangfuseTraceBody): string;
    protected eventStateless(body: CreateLangfuseEventBody): string;
    protected spanStateless(body: CreateLangfuseSpanBody): string;
    protected generationStateless(body: Omit<CreateLangfuseGenerationBody, "promptName" | "promptVersion"> & PromptInput): string;
    protected scoreStateless(body: CreateLangfuseScoreBody): string;
    protected updateSpanStateless(body: UpdateLangfuseSpanBody): string;
    protected updateGenerationStateless(body: Omit<UpdateLangfuseGenerationBody, "promptName" | "promptVersion"> & PromptInput): string;
    protected _getDataset(name: GetLangfuseDatasetParams["datasetName"]): Promise<GetLangfuseDatasetResponse>;
    getDatasetRun(params: GetLangfuseDatasetRunParams): Promise<GetLangfuseDatasetRunResponse>;
    createDatasetRunItem(body: CreateLangfuseDatasetRunItemBody): Promise<CreateLangfuseDatasetRunItemResponse>;
    /**
     * Creates a dataset. Upserts the dataset if it already exists.
     *
     * @param dataset Can be either a string (name) or an object with name, description and metadata
     * @returns A promise that resolves to the response of the create operation.
     */
    createDataset(dataset: string | {
        name: string;
        description?: string;
        metadata?: any;
    }): Promise<CreateLangfuseDatasetResponse>;
    /**
     * Creates a dataset item. Upserts the item if it already exists.
     * @param body The body of the dataset item to be created.
     * @returns A promise that resolves to the response of the create operation.
     */
    createDatasetItem(body: CreateLangfuseDatasetItemBody): Promise<CreateLangfuseDatasetItemResponse>;
    getDatasetItem(id: string): Promise<CreateLangfuseDatasetItemResponse>;
    protected _parsePayload(response: any): any;
    createPromptStateless(body: CreateLangfusePromptBody): Promise<CreateLangfusePromptResponse>;
    getPromptStateless(name: string, version?: number): Promise<GetLangfusePromptResponse>;
    /***
     *** QUEUEING AND FLUSHING
     ***/
    protected enqueue(type: LangfuseObject, body: any): void;
    /**
     * Asynchronously flushes all events that are not yet sent to the server.
     * This function always resolves, even if there were errors when flushing.
     * Errors are emitted as "error" events and the promise resolves.
     *
     * @returns {Promise<void>} A promise that resolves when the flushing is completed.
     */
    flushAsync(): Promise<void>;
    flush(callback?: (err?: any, data?: any) => void): void;
    processQueueItems(queue: LangfuseQueueItem[], MAX_MSG_SIZE: number, BATCH_SIZE_LIMIT: number): {
        processedItems: LangfuseQueueItem[];
        remainingItems: LangfuseQueueItem[];
    };
    _getFetchOptions(p: {
        method: LangfuseFetchOptions["method"];
        body?: LangfuseFetchOptions["body"];
    }): LangfuseFetchOptions;
    private constructAuthorizationHeader;
    private fetchWithRetry;
    shutdownAsync(): Promise<void>;
    shutdown(): void;
    protected awaitAllQueuedAndPendingRequests(): Promise<void>;
}
declare abstract class LangfuseWebStateless extends LangfuseCoreStateless {
    constructor(params: {
        publicKey: string;
    } & LangfuseCoreOptions);
    score(body: CreateLangfuseScoreBody): Promise<this>;
}
declare abstract class LangfuseCore extends LangfuseCoreStateless {
    private _promptCache;
    constructor(params: {
        publicKey: string;
        secretKey: string;
    } & LangfuseCoreOptions);
    trace(body?: CreateLangfuseTraceBody): LangfuseTraceClient;
    span(body: CreateLangfuseSpanBody): LangfuseSpanClient;
    generation(body: Omit<CreateLangfuseGenerationBody, "promptName" | "promptVersion"> & PromptInput): LangfuseGenerationClient;
    event(body: CreateLangfuseEventBody): LangfuseEventClient;
    score(body: CreateLangfuseScoreBody): this;
    getDataset(name: string): Promise<{
        id: string;
        name: string;
        description?: string;
        metadata?: any;
        projectId: string;
        items: Array<{
            id: string;
            input?: any;
            expectedOutput?: any;
            metadata?: any;
            sourceObservationId?: string | null;
            link: (obj: LangfuseObjectClient, runName: string, runArgs?: {
                description?: string;
                metadata?: any;
            }) => Promise<{
                id: string;
            }>;
        }>;
    }>;
    createPrompt(body: CreateChatPromptBody): Promise<ChatPromptClient>;
    createPrompt(body: CreateTextPromptBody): Promise<TextPromptClient>;
    getPrompt(name: string, version?: number, options?: {
        cacheTtlSeconds?: number;
        type?: "text";
    }): Promise<TextPromptClient>;
    getPrompt(name: string, version?: number, options?: {
        cacheTtlSeconds?: number;
        type: "chat";
    }): Promise<ChatPromptClient>;
    private _getPromptCacheKey;
    private _fetchPromptAndUpdateCache;
    _updateSpan(body: UpdateLangfuseSpanBody): this;
    _updateGeneration(body: UpdateLangfuseGenerationBody): this;
}
declare abstract class LangfuseObjectClient {
    readonly client: LangfuseCore;
    readonly id: string;
    readonly traceId: string;
    readonly observationId: string | null;
    constructor({ client, id, traceId, observationId, }: {
        client: LangfuseCore;
        id: string;
        traceId: string;
        observationId: string | null;
    });
    event(body: Omit<CreateLangfuseEventBody, "traceId" | "parentObservationId">): LangfuseEventClient;
    span(body: Omit<CreateLangfuseSpanBody, "traceId" | "parentObservationId">): LangfuseSpanClient;
    generation(body: Omit<CreateLangfuseGenerationBody, "traceId" | "parentObservationId" | "promptName" | "promptVersion"> & PromptInput): LangfuseGenerationClient;
    score(body: Omit<CreateLangfuseScoreBody, "traceId" | "parentObservationId">): this;
    getTraceUrl(): string;
}
declare class LangfuseTraceClient extends LangfuseObjectClient {
    constructor(client: LangfuseCore, traceId: string);
    update(body: Omit<CreateLangfuseTraceBody, "id">): this;
}
declare abstract class LangfuseObservationClient extends LangfuseObjectClient {
    constructor(client: LangfuseCore, id: string, traceId: string);
}
declare class LangfuseSpanClient extends LangfuseObservationClient {
    constructor(client: LangfuseCore, id: string, traceId: string);
    update(body: Omit<UpdateLangfuseSpanBody, "id" | "traceId">): this;
    end(body?: Omit<UpdateLangfuseSpanBody, "id" | "endTime" | "traceId">): this;
}
declare class LangfuseGenerationClient extends LangfuseObservationClient {
    constructor(client: LangfuseCore, id: string, traceId: string);
    update(body: Omit<UpdateLangfuseGenerationBody, "id" | "traceId" | "promptName" | "promptVersion"> & PromptInput): this;
    end(body?: Omit<UpdateLangfuseGenerationBody, "id" | "traceId" | "endTime" | "promptName" | "promptVersion"> & PromptInput): this;
}
declare class LangfuseEventClient extends LangfuseObservationClient {
    constructor(client: LangfuseCore, id: string, traceId: string);
}

export { type $defs, type ChatMessage, type ChatPrompt, ChatPromptClient, type CreateChatPromptBody, type CreateLangfuseDatasetBody, type CreateLangfuseDatasetItemBody, type CreateLangfuseDatasetItemResponse, type CreateLangfuseDatasetResponse, type CreateLangfuseDatasetRunItemBody, type CreateLangfuseDatasetRunItemResponse, type CreateLangfuseEventBody, type CreateLangfuseGenerationBody, type CreateLangfusePromptBody, type CreateLangfusePromptResponse, type CreateLangfuseScoreBody, type CreateLangfuseSpanBody, type CreateLangfuseTraceBody, type CreatePromptBody, type CreateTextPromptBody, type DeferRuntime, type GetLangfuseDatasetParams, type GetLangfuseDatasetResponse, type GetLangfuseDatasetRunParams, type GetLangfuseDatasetRunResponse, type GetLangfusePromptFailureData, type GetLangfusePromptResponse, type GetLangfusePromptSuccessData, type IngestionBody, type IngestionReturnType, type JsonType, LangfuseCore, type LangfuseCoreOptions, LangfuseEventClient, type LangfuseEventProperties, type LangfuseFetchOptions, type LangfuseFetchResponse, LangfuseGenerationClient, LangfuseMemoryStorage, type LangfuseMetadataProperties, type LangfuseObject, LangfuseObjectClient, LangfusePersistedProperty, type LangfusePromptClient, type LangfuseQueueItem, LangfuseSpanClient, LangfuseTraceClient, LangfuseWebStateless, type PromptInput, type SingleIngestionEvent, type TextPrompt, TextPromptClient, type UpdateLangfuseGenerationBody, type UpdateLangfuseSpanBody, type Usage, type components, type external, type operations, type paths, utils_d as utils, type webhooks };
